---
layout: post
title: "Tags em Go"
date: 2025-11-01
categories: [Golang]
tags: [blog, golang, tech, tag]
---

<p align="center">
  <img src="{{ '/assets/images/tags/imagem-inicial.png' | relative_url }}" alt="struct tags" style="max-width:100%;height:auto;">
</p>

## üìå Tags em Go üìå

Quanto mais no in√≠cio, vejo que tendemos a usar as "funcionalidades" sem entender o que h√° por tr√°s dos panos delas. N√£o sei voc√™, mas a mim, depois de um tempo, chega a me incomodar. Foi por isso que resolvi entender como funcionam as Tags em Go.

Para minha surpresa, ao pesquisar sobre o assunto, vi que n√£o h√° muito material sobre o tema, mesmo sendo uma capability bem legal e bastante utilizada. Ent√£o achei ser um bom ponto de partida para come√ßar o meu blog.

---

## ‚ùîO que s√£o‚ùî

Tags em Go t√™m uma defini√ß√£o bem simples e curta. Basicamente, s√£o marca√ß√µes que colocamos nas famosas structs. Essas marca√ß√µes s√£o baseadas em chave-valor e inseridas nos metadados dessas structs, permitindo que outros packages tenham a capacidade de realizar opera√ß√µes 
 
<p align="center">
  <img src="{{ '/assets/images/tags/struct-tag.png' | relative_url }}" alt="struct tags" style="max-width:100%;height:auto;">
</p>

E agora voc√™ deve estar se perguntando: e da√≠? O que de bom me traz ter informa√ß√µes no metadado da estrutura? E prontamente posso te responder: **flexibilidade**! 

---
## ‚ú® Beneficios

E para exemplificar esse benef√≠cio, consigo trazer de um pacote **nativo**, o [**enconding/json**](https://pkg.go.dev/encoding/json), que disponibiliza algumas funcionalidades para n√≥s. Como demonstro no c√≥digo abaixo, uma delas √© a convers√£o de uma estrutura em um slice de bytes, que podemos converter e exibir no terminal em formato de string.

<p align="center">
  <img src="{{ '/assets/images/tags/json-sem-tag.png' | relative_url }}" alt="json-sem-tagss" style="max-width:100%;height:auto;">
</p>

E ao executar o condigo temos o seguinte resultado:

<p align="center">
  <img src="{{ '/assets/images/tags/json-sem-tag-resultado.png' | relative_url }}" alt="json-sem-tags-resultado" style="max-width:100%;height:auto;">
</p>

Ao adicionar tag json na estrutura, o package json disponibiliza algumas features de customiza√ß√£o do mesmo. A mais comum √© a altera√ß√£o na chave do json, mas tamb√©m temos como excluir o item todo (exemplo abaixo no campo e-mail), dentre outras features.


<p align="center">
  <img src="{{ '/assets/images/tags/json-com-tag.png' | relative_url }}" alt="json-com-tagss" style="max-width:100%;height:auto;">
</p>

E ao executar o condigo temos o seguinte resultado:

<p align="center">
  <img src="{{ '/assets/images/tags/json-com-tag-resultado.png' | relative_url }}" alt="json-com-tags-resultado" style="max-width:100%;height:auto;">
</p>


Al√©m do json, temos nativamente tamb√©m para arquivos yaml, atrav√©s do [gopkg.in/yaml.v3](https://pkg.go.dev/gopkg.in/yaml.v2), o que pode ser uma baita m√£o na roda para trabalhar com arquivos de manifesto, por exemplo.

Mas nem s√≥ de nativo vive o homem. A comunidade tamb√©m traz bastante trabalhos com tags. Um dos mais conhecidos √© o validator do [go-playground](https://github.com/go-playground/validator), que nos traz a capability de, na pr√≥pria estrutura, definir regras necess√°rias para considerar aquela estrutura v√°lida, onde s√≥ precisa passar a estrutura para uma fun√ß√£o "Struct" do seu pacote.

<p align="center">
  <img src="{{ '/assets/images/tags/validator.png' | relative_url }}" alt="validator" style="max-width:100%;height:auto;">
</p>

Conseguimos identificar que ao popular a struct do exemplo acima, o campo e-mail n√£o √© para ser considerado validado, pois uma das features do validator √© o "email" que faz a verifica√ß√£o se a string corresponde a um regex valido de e-mail, com @ e um dominio (ex: @google.com), e aqui esta o resultado ao executar o codigo:

<p align="center">
  <img src="{{ '/assets/images/tags/validator-result.png' | relative_url }}" alt="validator result" style="max-width:100%;height:auto;">
</p>

Tamb√©m √© possivel fazer combina√ß√µes de tags, desde que respeitemos a sintaxe da linguagem:

<p align="center">
  <img src="{{ '/assets/images/tags/tags-tags.png' | relative_url }}" alt="tags-tags" style="max-width:100%;height:auto;">
</p>

E aproveitando a combina√ß√£o das tags json e validate, posso trazer um exemplo de usabilidade que a combina√ß√£o de ambas possam fazer sentido, um handler http, que fazemos decode de um body customizado, posteriormente validamos se esse body atende o minimo necessario, se n√£o devolvemos erro, caso atenda processamos:

<p align="center">
  <img src="{{ '/assets/images/tags/exemplo-uso.png' | relative_url }}" alt="exemplo-uso" style="max-width:100%;height:auto;">
</p>

S√≥ que tudo em programa√ß√£o s√£o tradeoffs, ent√£o iremos abordar um pouco o lado negativo do uso de tags

---

## üíÄ Maleficio

A palavra que assombra os criadores de tags acredito que √© **performance**, onde mesmo com o maior preciosismo e cuidado do mundo, c√≥digos espec√≠ficos para seu caso tendem a ser mais perform√°ticos que abordagens mais flex√≠veis e gen√©ricas.
Por exemplo os pr√≥prios criadores do validador se preocupam bastante com a perfomance, tanto que tem possui um arquivo de [benchmark](https://github.com/go-playground/validator/blob/master/benchmarks_test.go) bem extenso, mas mesmo com toda preocupa√ß√£o √© praticamente impossivel bater com valida√ß√µes especificas e diretas, como o benchmark mostra a seguir:

<p align="center">
  <img src="{{ '/assets/images/tags/benchmark.png' | relative_url }}" alt="benchmark" style="max-width:100%;height:auto;">
</p>

Antes de trazer o resultado, vale ressaltar que retirei da valida√ß√£o o e-mail, para termos valida√ß√µes mais simples possiveis (com maior e menor) e para quem n√£o conhece a ferramente de benchmark do go, algumas explica√ß√µes: 

Ap√≥s criar o usuario (e no caso do validator fazer o construtor dele), eu reseto o tempo para n√£o contabilizar no meu resultado, atrav√©s do b.ResetTimer(), o que quer dizer que tudo anterior ao resetador fun√ß√£o √© descartado. Posterior a resetar eu itero b.N vezes, onde o proprio go define dinamicamente o valor de N para equilibrar precis√£o do resultado com tempo de execu√ß√£o. Dito isto, bora pro resultado:

<p align="center">
  <img src="{{ '/assets/images/tags/benchmark-result.png' | relative_url }}" alt="benchmark-reuslt" style="max-width:100%;height:auto;">
</p>

Analisando o resultado, conseguimos ver que a fun√ß√£o que valida a estrutura atrav√©s do validator rodou ~3.6 milh√µes vezes levando 346.2ns/op (nanossegundo por opera√ß√£o) isso equivale a 0.0000003462s / 0.0003462ms. O que √© beeem rapido, mas se formos comparar com valida√ß√µes especificar e diretas temos 1 bilh√£o de itera√ß√µes levando 0.899 ns/op, o que √© uma grande diferen√ßa, mas isso inviabiliza o uso do validator? Na minha mais sincera opini√£o n√£o, dificilmente vamos precisar de extremo preciosismo na performance, se voce ja for usuario do validator e esta tendo gargalos, eu come√ßaria a investiga√ß√£o por outros lugares, pois o grande partes dos gargalos s√£o I/O e rede.


---

## üîç Acessando os metadados

Legal, ja entendemos o que s√£o, beneficios e maleficios das tags, mas at√© agora n√£o fa√ßo ideia de como acessar esses metadados, como que acessa esses benditos?
R: reflex√£o

Aqui eu poderia pensar em mil e uma frase para exemplificar o que √© reflex√£o, mas como todo bom desenvolvedor o famoso cntrl+c/cntrl+v √© bem eficaz, assim trago uma frase do [Rob Pike](https://pt.wikipedia.org/wiki/Rob_Pike) um dos co-criadores do go, retirada do artigo dele [The Laws of reflection](https://go.dev/blog/laws-of-reflection)

> *Reflex√£o em computa√ß√£o √© a capacidade de um programa examinar sua propria estrutura, particularmente por meio de tipos; √© uma forma de metaprograma√ß√£o*

E o go em especifico disponibiliza para a gente um pacote para o uso desse paradigma reflexivo, o temido package "reflect". Aqui um exemplo extremamente simples para conseguir acessar os valores das tags, pois relacionado a Tag realmente n√£o tem muita dificuldade para chegar at√© o campo e muitos possibilidades de trabalho, onde al√©m do Get (do exemplo abaixo) o campo Tag tem s√≥ mais um metodo √© o que Lookup que faz a mesma busca de um valor (chave da tag) em uma struct, onde retorna o valor ou uma string vazia (igual o get) por√©m com um booleno indicando se a chave existia (imaginado que fosse preenchido algo assim `custom:""`)

<p align="center">
  <img src="{{ '/assets/images/tags/reflect.png' | relative_url }}" alt="reflect" style="max-width:100%;height:auto;">
</p>

E por fim, executando o codigo...

<p align="center">
  <img src="{{ '/assets/images/tags/reflect-result.png' | relative_url }}" alt="reflect-result" style="max-width:100%;height:auto;">
</p>

Ent√£o conseguimos concluir que n√£o tem muita dificuldade quando falamos tags em si, onde toda a dificuldade de trabalhar com tag est√° na sua regra de negocio (o que voce√™ pretende fazer com ela) e no package reflect. E para os que n√£o conhecem o package reflect, vale dois pontos de aten√ß√£o, primeiro debugar ele √© bem complicado, mas vale a pena voc√™ se aventurar para entender o por que o debug n√£o √© t√£o agradavel. Segundo e mais importante o package reflect da muito "panic", e para quem n√£o esta familiarizado com o termo, panic √© um erro que geralmente a execu√ß√£o do seu programa vai ser interrompida, ent√£o tem que se tomar muito cuidado com os edge cases do seu programa, pois qualquer deslize pode cair nesse cenario.

<p align="center">
  <img src="{{ '/assets/images/tags/panic.png' | relative_url }}" alt="panic" style="max-width:100%;height:auto;">
</p>